#!/usr/bin/env node
// Build script: reads .env (PASSCODE) and message.txt, then outputs secrets.js
// with a SHA-256 hash of the passcode and AES-256-GCM encrypted message.
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

// Read .env
const envPath = path.join(__dirname, '.env');
if (!fs.existsSync(envPath)) {
  console.error('Missing .env file. Create one with PASSCODE=yourcode');
  process.exit(1);
}
const env = Object.fromEntries(
  fs.readFileSync(envPath, 'utf8').split('\n')
    .filter(l => l.includes('='))
    .map(l => { const i = l.indexOf('='); return [l.slice(0, i).trim(), l.slice(i + 1).trim()]; })
);
const passcode = env.PASSCODE;
if (!passcode) { console.error('PASSCODE not found in .env'); process.exit(1); }

// Read message
const msgPath = path.join(__dirname, 'message.txt');
if (!fs.existsSync(msgPath)) {
  console.error('Missing message.txt'); process.exit(1);
}
const message = fs.readFileSync(msgPath, 'utf8');

// Hash passcode with SHA-256
const passcodeHash = crypto.createHash('sha256').update(passcode).digest('hex');

// Encrypt message with AES-256-GCM using PBKDF2 key derived from passcode
const salt = crypto.randomBytes(16);
const key = crypto.pbkdf2Sync(passcode, salt, 100000, 32, 'sha256');
const iv = crypto.randomBytes(12);
const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
let ciphertext = cipher.update(message, 'utf8', 'base64');
ciphertext += cipher.final('base64');
const authTag = cipher.getAuthTag();

// Write secrets.js
const output = `// Auto-generated by build-secrets.js â€” do not edit
// Passcode hash and encrypted message for the hidden envelope feature
const ENVELOPE_SECRETS = {
  passcodeHash: "${passcodeHash}",
  salt: "${salt.toString('base64')}",
  iv: "${iv.toString('base64')}",
  authTag: "${authTag.toString('base64')}",
  ciphertext: "${ciphertext}"
};
`;

fs.writeFileSync(path.join(__dirname, 'secrets.js'), output);
console.log('secrets.js generated successfully');
